#!/usr/bin/env python3
"""
usage:
    permutation encode //
    permutation decode //
    permutation help //

e.g. tragedia malinteso attorno lacuna invece michele produrre vispo
     brillante buio valgo umano
     A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♦ 2♦ 3♦ 4♦ 4♠ 5♠ 8♠ 3♣
     4♣ 8♦ 7♦ 2♣ K♠ Q♠ 7♠ J♦ 9♠ 9♣ A♣ Q♦ 5♦ 10♠ 3♠ K♦ K♣ 10♦ 10♣ 2♠
     9♦ J♠ 8♣ A♠ Q♣ 6♠ J♣ 6♦ 6♣ 7♣ 5♣
"""
import argparse
from math import log2
from getpass import getpass
import sys
from random import getrandbits
from permutation.ordering import (
    encode, decode, get_ordering_length, get_orderings)
from permutation.mnemonic import (
    mnemonic_to_integer, integer_to_mnemonic, get_languages)
from permutation.encryption import crypt, decrypt
from permutation.utils import integer_to_bytes, bytes_to_integer
from permutation.mapping import fact


def get_passwd():
    """Wrap getpass"""
    password = None
    while True:
        password = getpass('Insert the password: ')
        confirm = getpass('Confirm the password: ')
        if password != confirm:
            print('Retry')
        else:
            break
    return password


def encoding_len(max_len):
    """Compute the len of the clear data
    Round to multiple of 4
    Remove header: clear text, xxtea
    """

    def simulate(length):
        """Simulate enc. Doc only"""
        length += 2  # Add header
        if length % 4 == 0:
            return max(length, 8)
        return max((length // 4 + 1) * 4, 8)

    return max_len // 4 * 4 - 2


def b2x(bb):
    return '0x' + ''.join(['%02x' % y for y in bb])


def log(*args):
    """ print to stderr """
    print(*args, file=sys.stderr)


def crypt_data(integer, mode, ordering, password):
    """Do encrypt operations"""

    # available length
    max_bits = int(log2(
        fact(get_ordering_length(ordering)) // 2
    ))
    length = max_bits // 8
    useless_bits = max_bits % 8
    assert 0 <= useless_bits <= 7
    # useless_bits: the most significant bits that will be encoded
    # in the permutation. They are less than a byte so the encryption function
    # do not use them.
    # We assign a random value to them to preserve plausible deniability

    max_len = length
    if mode == 'encode':
        length = encoding_len(length)
    elif mode == 'decode':
        if useless_bits:
            # If there is padding we need one more byte to decode it
            length += 1
    data = integer_to_bytes(integer, length)
    log('input in bytes', b2x(data), len(data))
    if mode == 'encode':
        data = crypt(data, password, True)
        useless_bytes = max_len - len(data)
        assert len(data) <= max_len, (
            'Encrypted data is too long (%d, max %d)' % (len(data), max_len))
        assert 0 < useless_bytes < 4, (
            'useless_bytes not valid (%d)' % (useless_bytes, ))
        if useless_bytes:
            # Add bytes padding
            padding = bytes([getrandbits(8) for _ in range(useless_bytes)])
            data = padding + data
        if useless_bits:
            padding = bytes([getrandbits(useless_bits)])
            log('useless_bits', useless_bits)
            log('len(data1)', len(data))
            log('padding', padding[0])
            data = padding + data
    elif mode == 'decode':
        # Remove padding bits
        if useless_bits:
            data = data[1:]
            log('padding bits removed', b2x(data), len(data))
        # Remove padding bytes
        if len(data) % 4:
            data = data[len(data) % 4:]
        data = decrypt(data, password, True)
    log('output in bytes', b2x(data), len(data))
    integer = bytes_to_integer(data)
    assert log2(integer) <= max_bits, (
        'Encrypted integer is too long (%.2f, max %d)' % (
            log2(integer), max_bits))

    if mode == 'encode':
        used = log2(integer)
        total = log2(fact(get_ordering_length(ordering)) // 2)
        log('Used bits %.2f - %.2f = %.2f' % (total, used, total - used))
        # If we leave suspicious null bits on the right (or in other places)
        # plausible deniability is lost

    return integer


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('mode', type=str,
                        help='encode, decode, languages or orderings')
    parser.add_argument('--ordering', dest='ordering', type=str,
                        default='french-symbols',
                        help='objects of the permutation')
    parser.add_argument('--language', dest='language', type=str,
                        default='english',
                        help='~ of the seed wordlist')
    parser.add_argument('--sep', dest='sep', type=str,
                        default=' ',
                        help='separator of permutation labels')
    # Unsafe arguments
    parser.add_argument('--seed-unsafe', dest='seed', type=str,
                        help='BIP39 seed. *UNSAFE*')
    parser.add_argument('--password-unsafe', dest='password', type=str,
                        help='*UNSAFE*')
    parser.add_argument('--permutation-unsafe', dest='permutation', type=str,
                        help='*UNSAFE*')

    args = parser.parse_args()

    password = args.password or get_passwd()

    if args.mode == 'encode':
        seed = args.seed or input('BIP39 seed: ')
        integer = mnemonic_to_integer(seed.split(
            None if args.sep == ' ' else args.sep))
        log('decrypted integer', integer)
        integer = crypt_data(integer, args.mode, args.ordering, password)
        log('encrypted integer', integer)
        print(args.sep.join(decode(args.ordering, integer)))
    elif args.mode == 'decode':
        perm = args.permutation or input('Cards permutation: ')
        integer = encode([word.strip() for word in perm.split(args.sep)])
        log('encrypted integer', integer)
        integer = crypt_data(integer, args.mode, args.ordering, password)
        log('decrypted integer', integer)
        print(args.sep.join(integer_to_mnemonic(integer, args.language)))
    elif args.mode == 'languages':
        print(' '.join(get_languages()))
    elif args.mode == 'orderings':
        print(' '.join(get_orderings()))

if __name__ == "__main__":
    main()
